#! usr/bin/Rscript

## load the packages
library(tidyverse)
library(data.table)
library(knitr)
library(broom)
library(matrixStats)

## Part A. Load sum stats (PMID 25056061; Nature 2014)

#1. read in the data
sumstat.filename <- "path/to/SCZ/Nature2014/daner_PGC_SCZ52_0513a.hq2.gz"
SCZ = read_tsv(paste0(sumstat.filename))

#2. select the required columns, rename them 
SCZ.df = SCZ %>% as.data.frame()%>% 
  dplyr::select(c("CHR", "BP", "SNP", "OR", "P"))%>%
  dplyr::rename(c(BETA="OR"))

#3. order by chromosome and position
SCZ.ord = SCZ.df[order(SCZ.df$CHR, SCZ.df$BP),]

#4. retain only valid rsIDs
SCZ.eu = SCZ.ord[which(substr(SCZ.ord$SNP,1,2)=='rs'),] #10,172,956 --> 9,272,258

#5. save
write.table(SCZ.eu, file = 'PGC_SCZ_2014_sumstats.txt', sep = "\t")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

data=SCZ.eu

## Part B. Create a vector of overlapping and equal-in-size coordinates of DNA seq
#Here I use the first and the last snp position per chromosome, the length of segments (or the interval) 
#can be anywhere between 1 to 2 Mbp, the overlap is set at 25%. 

#1. initialize a list to store intVs for each group
intVs_list <- list()  

#2. loop it over each chromosome
for (chr in unique(data$CHR)) {
  first <- min(data$BP[data$CHR == chr], na.rm = TRUE)
  last <- max(data$BP[data$CHR == chr], na.rm = TRUE)
  interval <- 2000000
  overlap <- 500000
  
  intVs <- c()  # Create an empty vector for the current group
  
  inc <- ceiling((last - first) / (interval - overlap))
  start <- first
  
  for (i in 1:inc) {
    end <- start + interval
    intV <- paste(start, end, sep = ':')
    
    intVs <- c(intVs, intV)
    start <- end - overlap
  }
  
  intVs_list[[chr]] <- intVs  # Store intVs for the current group in the list
}

#3. convert the list of vectors to a list of data frames
coord_list <- lapply(intVs_list, function(vector) {
  split_vector <- strsplit(vector, ":")
  coord_df <- do.call(rbind, lapply(split_vector, function(x) data.frame(seg_start = x[1], seg_end = x[2])))
  return(coord_df)
})

#4. rbind all data frames in the list with ID (index)
coord_df <- do.call(rbind, Map(cbind, index = seq_along(coord_list), coord_list))
table(coord_df$index) # check the indices match the chromosome number

#5. save
write.table(coord_df, file = 'coordinates_for_PGC_SCZ_2014_sumstats.txt', sep = "\t")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Part C. Extract information 
# Here, I use the coordinates calculated in the previous step to extract all the snps in the summary 
# statistics file, whose position is whithin the intervals/windows/regions. I look in the snps count and also 
# the avergae Betas per region per chromosome.

#1. create an empty data frame
result <- data.frame()

#2. loop through conditions
for (chr in unique(data$CHR)){
  sub.dt <- subset(data, CHR==chr)
    sub.coord <- subset(coord_df, index==chr)
    for (j in 1:(nrow(sub.coord) -3)) {
      spot1 <- as.numeric(sub.coord[j, 2])  # Access value from dataset2
      spot2 <- as.numeric(sub.coord[j+3, 2])
      sub.dt_tmp <- sub.dt[which(sub.dt$BP>=spot1 & sub.dt$BP<spot2), ]
      if (nrow(sub.dt_tmp) >0){
        snp.counts <- length(sub.dt_tmp$BETA)
        sum.beta.eu<- sum((sub.dt_tmp$BETA))/length(sub.dt_tmp$BETA)
        start.pos <- min(sub.dt_tmp$BP)
        end.pos <- max(sub.dt_tmp$BP)
        stats <- data.frame(chr, start.pos, end.pos, snp.counts, Avg.beta)
        result <- rbind(result, stats)  
      }
    }
}

#3. check the output
head(result)

#4. save
write.csv("result", file = 'path/to/A/Folder/Results_counts_beta_perRegion_for_PGC_SCZ_2014_sumstats.txt', )


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Part D. Visualization

#1. Define a function to calculate all quantiles
Quantil_Func <- function(x) {
  quantiles <- quantile(x, probs = seq(0, 1, 1/20)) 
  
  Iqr5_95 <- quantiles[20] - quantiles[2]
  Iqr25_75 <- quantiles[16] - quantiles[6]
  
  res <- c(quantiles, Iqr25_75, Iqr5_95)
  
  return(res)
}

#2. Calculate quantiles for snp.counts
q_out <- Quantil_Func(result$snp.counts)
barplot(q_out[1:21])


#3. Exclude ouliers (smallest 5% and biggest 5% counts)
filtr.dt <- result %>% 
  filter(snp.counts > quantile(snp.counts, 0.05) & snp.counts < quantile(snp.counts, 0.95)) #178 SNPs are removed

                                                                                  
#4. Calculate the counts zscore
filtr.dt  <- filtr.dt  %>% 
  mutate(ZCounts = as.numeric(scale(snp.counts)))

#5. plot
hist(filtr.dt$ZCounts, xlab="SNP Counts (scaled)", main="SNP Counts (scaled) \n After Filter")
hist(filtr.dt$snp.counts, xlab="SNP RAW Counts", main="SNP RAW Counts \n After Removing Outliers")


#5. How removing outliers affected the pvalues?

#check it on the main data
model_effects = result %>% 
  do(tidy(lm(Avg.beta ~ snp.counts,  data = .))) %>%
  mutate(padj = p.adjust(`p.value`, method = 'BH')) 

print(model_effects)
# term        estimate     std.error statistic p.value  padj
# <chr>          <dbl>         <dbl>     <dbl>   <dbl> <dbl>
# 1 (Intercept)  1.00e+0 0.000112       8974.      0     0    
# 2 snp.counts  -2.11e-9 0.00000000718    -0.294   0.768 0.768
#######################################
# check it on the filtered data
model_effects2 = filtr.dt %>% 
  do(tidy(lm(Avg.beta ~ snp.counts,  data = .))) %>%
  mutate(padj = p.adjust(`p.value`, method = 'BH')) 

print(model_effects2)

# term             estimate     std.error statistic    p.value       padj
# <chr>               <dbl>         <dbl>     <dbl>      <dbl>      <dbl>
# 1 (Intercept)  1.00         0.0000759      13194.   0          0         
# 2 snp.counts  -0.0000000223 0.00000000497     -4.49 0.00000770 0.00000770

# removing outliers (windows with extrem low or high SNP counts),
# does affect on the significance of the correlation of beta and counts. 

library(ggpubr) # to add fitted regression equation inside
ggplot(data=filtr.dt, aes(x = snp.counts, y = Avg.beta)) + 
  geom_point() +
  stat_smooth(method = "lm", se=FALSE) +
  stat_regline_equation(label.x.npc = "center")+
  theme_bw()

###############################################################################################################################################














