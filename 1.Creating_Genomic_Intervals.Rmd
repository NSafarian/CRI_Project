---
title: "Cumulative Regional Impact (CRI) Analysis Pipeline"
Author: Nickie Safarian
output: html_document
date: "2023-07-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## **R Markdown**
In this example, we use a newly developed statistical method to identify regions/blocks of DNA sequence where the cumulative regional burden 
scores for carrying functional variants are high. 
This is a fairly intuitive approach which can aid in interpretation of WGS/WES data.


## **1. Set up analysis folders**
Set up a folder structure to organize your data analysis.
```{r}
# Create the data folder if it doesn't exist
if (!dir.exists("data")) {
  dir.create("data")
}

# Define the file path to the plots directory
plots_dir <- "plots"

# Create the plots folder if it doesn't exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir)
}

# Define the file path to the results directory
results_dir <- "results"

# Create the results folder if it doesn't exist
if (!dir.exists(results_dir)) {
  dir.create(results_dir)
}
```{r}
In the same place you put this .Rmd file, you should now have three new empty folders called data, plots, and results!


##1.2. Download the summary statistics data 
*for the purpose of presentation, I have used the the Psychiatric Genomics Consortium (PGC) summary statistics*
*for schizophrenia published on **2014**:*
*<pubMedIDlink: https://pubmed.ncbi.nlm.nih.gov/25056061; download link: https://doi.org/10.6084/m9.figshare.14672163>.*

Create a subfolder in the newly created **data** folder and named it **SCZ2014**. Now, put the downloaded summary stats in this subfolder. 
If later on you decided to download other summary statas files, you can keep them organized in separate subfolders.

##1.3.  Define the file path to the data directory
```{r]
# Replace with the path of the folder the files will be in
data_dir <- file.path("data", "SCZ2014")

# Declare the file path to the gene expression matrix file
# inside directory saved as `data_dir`
# Replace with the path to your dataset file
data_file <- file.path(data_dir, "daner_PGC_SCZ52_0513a.hq2.gz")
```{r}

    
##1.4. Import and set up data
```{r}
SCZ = readr::read_tsv(data_file)

#select and rename columns (if necessary), and retain only valid rsIDs
SCZ.df = SCZ %>% as.data.frame()%>% 
  dplyr::select(c("CHR", "BP", "SNP", "OR", "P"))%>%
  dplyr::rename(c(BETA="OR"))%>%
  dplyr::filter(str_detect(SNP, 'rs'))

#order by chromosome and position
data = SCZ.df[order(SCZ.df$CHR, SCZ.df$BP),]

```{r}

## **2. Create a vector of overlapping and equal-in-size coordinates of DNA seq**
Note: here, the first and the last snp position per chromosome are set as start and end coordinates.
The length of segments (or the interval) is set to 1Mbp, the overlap is set at 50%. 

```{r}
#2.1. initialize a list to store intVs for each group
intVs_list <- list()  

#2.2. loop it over each chromosome
for (chr in unique(data$CHR)) {
  first <- min(data$BP[data$CHR == chr], na.rm = TRUE)
  last <- max(data$BP[data$CHR == chr], na.rm = TRUE)
  interval <- 1000000
  overlap <- 500000
  
  intVs <- c()  # Create an empty vector for the current group
  
  inc <- ceiling((last - first) / (interval - overlap))
  start <- first
  
  for (i in 1:inc) {
    end <- start + interval
    intV <- paste(start, end, sep = ':')
    
    intVs <- c(intVs, intV)
    start <- end - overlap
  }
  
  intVs_list[[chr]] <- intVs  # Store intVs for the current group in the list
}

#2.3. convert the list of vectors to a list of data frames
coord_list <- lapply(intVs_list, function(vector) {
  split_vector <- strsplit(vector, ":")
  coord_df <- do.call(rbind, lapply(split_vector, function(x) data.frame(seg_start = x[1], seg_end = x[2])))
  return(coord_df)
})

#2.4. rbind all data frames in the list with ID (index)
coord_df <- do.call(rbind, Map(cbind, index = seq_along(coord_list), coord_list))
table(coord_df$index) # check the indices match the chromosome number

#2.5. save
write.table(coord_df, file = file.path("results",'coordinates_for_PGC_SCZ_2014_sumstats.txt', sep = "\t"))
                      
```{r}
Now you have a data frame containing coorinates columns for start and end of arbiteray segments per chromosome.

## **3. Explore the results**                   
Here, the number of snps and the average beta values per region per chromosome is calculated. 
```{r}
#3.1. create an empty data frame
result <- data.frame()

#3.2. loop through conditions
for (chr in unique(data$CHR)){
  sub.dt <- subset(data, CHR==chr)
    sub.coord <- subset(coord_df, index==chr)
    for (j in 1:(nrow(sub.coord) -3)) {
      spot1 <- as.numeric(sub.coord[j, 2])  # Access value from dataset2
      spot2 <- as.numeric(sub.coord[j+3, 2])
      sub.dt_tmp <- sub.dt[which(sub.dt$BP>=spot1 & sub.dt$BP<spot2), ]
      if (nrow(sub.dt_tmp) >0){
        snp.counts <- length(sub.dt_tmp$BETA)
        sum.beta.eu<- sum((sub.dt_tmp$BETA))/length(sub.dt_tmp$BETA)
        start.pos <- min(sub.dt_tmp$BP)
        end.pos <- max(sub.dt_tmp$BP)
        stats <- data.frame(chr, start.pos, end.pos, snp.counts, Avg.beta)
        result <- rbind(result, stats)  
      }
    }
}

#3.3. check the output
head(result)

#3.4. save
write.csv("result", file = file.path("results", 'CRIResults_for_PGC_SCZ_2014_sumstats.txt', )
```{r}

Next, we'll use this result file to investigate cumulative regional impact of snps.

          

          






    

